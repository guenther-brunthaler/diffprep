#! /bin/sh
set -e
target=diffprep
cleanup() {
	local rc; rc=$?
	test -n "$TD" && rm -r -- "$TD"
	test $rc = 0 || echo "$0 failed!" >& 2
}
TD=
trap cleanup 0

redir_output() {
	local target; target=$1; shift
	"$@" > "$target"
}

run() {
	"$@" && return
	{
		echo "There was a problem executing the following command:"
		echo ">>>$*<<<"
		echo "Examine, then 'exit' to quit."
	} >& 2
	xterm -e "$SHELL" -l
	false || exit
}

# The last character in each of the space-separated groups needs to be the
# option character for converting back the transformed test case into the
# original. The remaining characters are the (clustered) option characters for
# transforming the original.
tests='bB xX baB xaX wW cC'
verbose=true
while getopts qt: opt
do
	case $opt in
		q) verbose=false;;
		t) tests=$OPTARG;;
		*) false || exit
	esac
done
shift `expr $OPTIND - 1 || :`
test -n "$SHELL"
run test -n "$tests"
run test $# != 0
run make -s -- "$target"
run test -f "$target"
run test -x "$target"
TD=`mktemp -d -- "${TMPDIR:-/tmp}/${0##*/}.XXXXXXXXXX"`
for f
do
	test -f "$f"
	# For examiner's sake.
	$verbose && echo "Test case '$f':" >& 2
	printf '%s\n' "$f" > "$TD"/origin
	cat "$f" > "$TD"/from
	cp -p -- "$target" "$TD"/
	for modes in $tests
	do
		run test ${#modes} -ge 2
		into=${modes%?}
		back=${modes#"$into"}
		$verbose && printf %s "-$into" >& 2
		run ./"$target" -$into "$TD"/from > "$TD"/into
		$verbose && printf %s " and -$back" >& 2
		run redir_output "$TD"/back ./"$target" -$back < "$TD"/into
		set cmp -s -- ""$TD"/back" "$f"
		if "$@"
		then
			echo " passed."
		else
			echo " FAILED!"
			run "$@"; false || exit
		fi
	done
done
echo "All tests passed!" >& 2
